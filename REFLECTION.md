What part of the code was most confusing and why?
    The interval portion of the code was the most difficult to understand, and I especially had a hard time with the modulo loop. It was a good reminder that an infinite loop can be created technically, but since the code will be read top-down then the caveats and conditions can still be defined to "interrupt" the infinite loop. Otherwise the logic between definining the elements, functions, and then the behaviors of those functions makes the code very easy to follow.

How does the animation help visualize asynchronous behavior?
    The animation significantly improves the user experience if this were actually a loading screen. It's only a few images, but they made it clear that the program was moving along behind the scenes. Staring at a screen that isn't doing anything not only makes users think that something is wrong, but it also causes unnecessary refreshes or exits. The fact that I could make the code wait a few milliseconds between changing through the frames also helped me understand where the asynchronicity actually came from in this code. I initially thought the MS wait time was for when the page first loaded up, but seeing it in action after changing the value significantly helped with seeing the purpose behind the delay.
What did you change or improve, and what effect did it have?
    One of the things I experimented with was the amount of MS that the code "waited" between frames, and I accidentally broke it. I wanted to see what it would do if I waited 0 or 1 ms, but the code got stuck on the loading screen instead. I couldn't figure out why, but Gemini said the issue was that the logic just didn't have time the capacity to run without delay like that due to the event handling, so it got hung up. I then set the MS to 1000 to see it in action without crashing, and was able to see what the delay was for.